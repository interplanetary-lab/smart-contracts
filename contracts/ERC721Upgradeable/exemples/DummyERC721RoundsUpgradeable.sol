// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "../ERC721RoundsUpgradeable.sol";

/**
 * @dev Dummy contract test the management of mint rounds with {ERC721RoundsUpgradeable}
 * @author Nicolas SENECAL - @senecolas
 */
contract DummyERC721RoundsUpgradeable is
    ERC721RoundsUpgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable
{
    /// Maximum supply of all contract
    uint256 public constant MAX_SUPPLY = 11_111;

    /// Number of tokens that a wallet can mint in a public round
    uint256 public maxMintsPerWallet;

    /**
     * CONSTRUCTOR
     *
     * @custom:oz-upgrades-unsafe-allow constructor
     */
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initialize the contract
     */
    function initialize() public initializer {
        __ERC721_init("Dummy", "DUM");
        __Ownable_init();
        __UUPSUpgradeable_init();

        maxMintsPerWallet = 3;
    }

    /**
     * @notice Mint the `amount` of tokens in a public round.
     *
     * @dev Call {ERC721RoundsUpgradeable-_publicRoundMint}.
     * @dev Requirements:
     * - Total minted for the user during this round must be less than `maxMintsPerWallet`
     * - View {ERC721RoundsUpgradeable-_publicRoundMint} requirements
     *
     * @param roundId The mint round index
     * @param amount The number of tokens to mint
     */
    function mint(uint256 roundId, uint256 amount) external payable virtual {
        require(
            totalMintedBy(msg.sender, roundId) + amount <= maxMintsPerWallet,
            "Max allowed"
        );
        _publicRoundMint(msg.sender, roundId, amount);
    }

    /**
     * @notice Mint the `amount` of tokens with the signature of the round validator.
     *
     * @dev Call {ERC721RoundsUpgradeable-_privateRoundMint}.
     * @dev Requirements:
     * - View {ERC721RoundsUpgradeable-_privateRoundMint} requirements
     *
     * @param roundId The mint round index
     * @param amount The number of tokens to mint
     * @param maxMint The maximum token that the user is allowed to mint in the round (verified in `sig`)
     * @param payloadExpiration The maximum timestamp before the signature is considered invalid (verified in `sig`)
     * @param sig The EC signature generated by the wave validator
     */
    function privateMint(
        uint256 roundId,
        uint256 amount,
        uint256 maxMint,
        uint256 payloadExpiration,
        bytes memory sig
    ) external payable virtual {
        _privateRoundMint(
            msg.sender,
            roundId,
            amount,
            maxMint,
            payloadExpiration,
            sig
        );
    }

    /**
     * @dev Create or edit a round
     *
     * @dev Call {ERC721RoundsUpgradeable-_setupRound}.
     * @dev Requirements:
     * - msg.sender is owner of the contract
     * - View {ERC721RoundsUpgradeable-_setupRound} requirements
     *
     * @param roundId The round identifier
     * @param supply Number of tokens that can be minted in this round. Can be 0 for no supply control.
     * @param startTime The start date of the round in seconds
     * @param duration The duration of the round in seconds. Can be 0 for no time limitation
     * @param validator The address of the whitelist validator. Can be 'address(0)' for no whitelist
     * @param price The price of the round in ETH (can be 0)
     */
    function setupRound(
        uint256 roundId,
        uint32 supply,
        uint64 startTime,
        uint64 duration,
        address validator,
        uint256 price
    ) external virtual onlyOwner {
        _setupRound(roundId, supply, startTime, duration, validator, price);
    }

    /**
     * @notice Check the max supply before the mint
     *
     * @param to The wallet to transfer new tokens
     * @param amount The number of tokens to mint
     */
    function _beforeMint(address to, uint256 amount) internal virtual override {
        require(_totalMinted + amount <= MAX_SUPPLY, "Supply exceeded");
        super._beforeMint(to, amount);
    }

    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyOwner
    {}
}
